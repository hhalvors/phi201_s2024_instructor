<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Hans Halvorson" />
  <title>logic precept 4</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">logic precept 4</h1>
<p class="author">Hans Halvorson</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>Today we develop a different approach to looking at (formal)
arguments. Many of you will already have heard about the notion of a
truth table. What you might not have heard is how truth tables are
related to proofs. We will postpone the deeper conceptual issues until
next week. But this week we will see how to write the joint truth table
for <span class="math inline"><em>n</em></span> sentences, and how to
interpret the resulting output. We will then talk about some short-cuts
that one might employ – rather than writing out a full truth table. In
practice these short cuts can be crucial, as writing a full truth table
is incredibly inefficient for more complex sentences. What’s more,
writing a full truth table is a completely mindless (algorithmic)
process, whereas there are other methods that involve interesting
strategies. (For you COS people: we are touching here on the infamous
P=NP problem, which is, unfortunately, too advanced to talk about
explicitly in this course.)</p>
<h1 id="truth-tables">Truth tables</h1>
<p>Let’s first recall the truth tables for the connectives.</p>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>¬P</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>F</td>
</tr>
<tr class="even">
<td>F</td>
<td>T</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>Q</th>
<th style="text-align: center;">P ∧ Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>T</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="even">
<td>F</td>
<td>F</td>
<td style="text-align: center;">F</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>Q</th>
<th style="text-align: center;">P ∨ Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="odd">
<td>F</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>F</td>
<td>F</td>
<td style="text-align: center;">F</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>Q</th>
<th style="text-align: center;">P → Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>F</td>
<td>F</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>P</th>
<th>Q</th>
<th style="text-align: center;">P ↔︎ Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>T</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="even">
<td>F</td>
<td>F</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>The bad news is that you just need to memorize these. The good news
is that once you write circa 10 truth tables, you will automatically
memorize them.</p>
<p>The typical task is to write a truth table for <span
class="math inline"><em>n</em></span> sentences. To do that, we simply
write the sentences together on a line, leaving some space to the left.
On the left, we then add columns for each of the <em>atomic
sentences</em> that occurs in these sentences. Then we write out all
possible combinations of assignments of truth values to those atomic
sentences. One easy way to make sure to capture all of them is to list
the atomic sentences in alphabetic order. Then write T in the first
<span class="math inline">2<sup><em>n</em> − 1</sup></span> rows under
the first letter, and F in the subsequent <span
class="math inline">2<sup><em>n</em> − 1</sup></span> rows under the
first letter. (That makes for a total of <span
class="math inline">2<sup><em>n</em> − 1</sup> + 2<sup><em>n</em> − 1</sup> = 2(2<sup><em>n</em> − 1</sup>) = 2<sup><em>n</em></sup></span>
rows.) Under the second letter, write T in the first <span
class="math inline">2<sup><em>n</em> − 2</sup></span> rows, and F in the
next <span class="math inline">2<sup><em>n</em> − 1</sup></span> rows,
then T in the next <span
class="math inline">2<sup><em>n</em> − 2</sup></span> rows, then F in
the last <span class="math inline">2<sup><em>n</em> − 2</sup></span>
rows. If you continue with this procedure, then under the last atomic
sentence, you will alternate between T and F.</p>
<p>Now the tedium really begins. If you want to write out every single
detail, you can now proceed to copying those Ts and Fs under the atomic
sentences as they occur in the original sentences. Then you proceed
outward, assigning T and F to the Boolean combinations of things that
you have already assigned T and F to. (If you are a visual thinker, you
might be able to imagine that T and F are flowing down the branches of
the parse-tree of the sentence, following the rules given by the truth
tables.)</p>
<p><strong>Exercise.</strong> Write a full truth table for <span
class="math inline">(<em>P</em>∧<em>Q</em>) ∨ (¬<em>P</em>∧¬<em>Q</em>)</span>.</p>
<p><strong>Exercise.</strong> Write a full truth table for <span
class="math inline">(<em>P</em>∧<em>Q</em>) ∨ ¬(<em>P</em>→<em>Q</em>)</span>.</p>
<p><strong>Exercise.</strong> Write a full truth table for <span
class="math inline">(<em>P</em>→<em>Q</em>) → <em>R</em></span>.</p>
<h1 id="sentence-structure">Sentence structure</h1>
<p>Each sentence of proposition logic is either atomic, or it has a
<strong>main connective</strong>. This main connective is the last
connective that is added in the construction of the sentence — a notion
that can be defined more precisely than we have so far. It can be a good
idea, when you are writing a truth table, to circle or highlight thex
column under the main connective so as to be clear about the meaning of
the truth table.</p>
<p><strong>Exercise.</strong> What is the main connective of each of the
following formulas?</p>
<ol type="1">
<li><p><span
class="math inline">¬(<em>P</em>→<em>Q</em>)</span></p></li>
<li><p><span
class="math inline">¬<em>P</em> → <em>Q</em></span></p></li>
<li><p><span
class="math inline">¬(<em>P</em>→¬<em>Q</em>)</span></p></li>
<li><p><span
class="math inline">(<em>P</em>∧<em>Q</em>) ∨ ¬(<em>P</em>→<em>Q</em>)</span></p></li>
<li><p><span
class="math inline">((<em>P</em>→<em>Q</em>)→<em>P</em>) → <em>P</em></span></p></li>
</ol>
<h2 id="parse-trees">Parse trees</h2>
<p><img src="tree.jpg" /></p>
<h1 id="aside-for-programmers">Aside for programmers</h1>
<p>A truth table for a sentence is a completely explicit representation
of the values of the set of all truth functions as applied to that
sentence. Given a list <span class="math inline"><em>Σ</em></span> of
propositional constants, a truth function on <span
class="math inline"><em>Σ</em></span> is just an assignment of T and F
to all the elements in <span class="math inline"><em>Σ</em></span>. Such
an assignment then extends naturally to all sentences built out of the
propositional constants in <span
class="math inline"><em>Σ</em></span>.</p>
<p>We could tighten up this definition by first defining the type
<code>WFF</code> of well-formed formulas of propositional logic. Here’s
what the definition of such a type might look like in the Haskell
programming language:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">WFF</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span>         <span class="co">-- A propositional variable</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Not</span> <span class="dt">WFF</span>            <span class="co">-- Negation</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">And</span> <span class="dt">WFF</span> <span class="dt">WFF</span>        <span class="co">-- Conjunction</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Or</span> <span class="dt">WFF</span> <span class="dt">WFF</span>         <span class="co">-- Disjunction</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Imply</span> <span class="dt">WFF</span> <span class="dt">WFF</span>      <span class="co">-- Implication</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Iff</span> <span class="dt">WFF</span> <span class="dt">WFF</span>        <span class="co">-- Biconditional (if and only if)</span></span></code></pre></div>
<p>Here’s an example of a WFF.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleWFF ::</span> <span class="dt">WFF</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>exampleWFF <span class="ot">=</span> <span class="dt">Imply</span> (<span class="dt">And</span> (<span class="dt">Var</span> <span class="st">&quot;p&quot;</span>) (<span class="dt">Not</span> (<span class="dt">Var</span> <span class="st">&quot;q&quot;</span>))) (<span class="dt">Or</span> (<span class="dt">Var</span> <span class="st">&quot;r&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;s&quot;</span>))</span></code></pre></div>
<p>This example is clear for a computer, but less clear to a human eye.
We prefer to see something like <span
class="math inline">(<em>p</em>∧¬<em>q</em>) → (<em>r</em>∨<em>s</em>)</span>.</p>
<p>With the type <code>WFF</code> defined, we can then define a type
<code>TruthFunction</code>, which uses a type <code>Env</code> as an
auxiliary. (An Environment is essentially a truth-valuation, i.e. an
assignment of truth values to atomic sentences.)</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Bool</span>)]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">TruthFunction</span> <span class="ot">=</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">WFF</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">TruthFunction</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>eval env (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> x env <span class="kw">of</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">Just</span> val <span class="ot">-&gt;</span> val</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Variable not found&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>eval env (<span class="dt">Not</span> wff) <span class="ot">=</span> <span class="fu">not</span> (eval env wff)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>eval env (<span class="dt">And</span> wff1 wff2) <span class="ot">=</span> (eval env wff1) <span class="op">&amp;&amp;</span> (eval env wff2)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>eval env (<span class="dt">Or</span> wff1 wff2) <span class="ot">=</span> (eval env wff1) <span class="op">||</span> (eval env wff2)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>eval env (<span class="dt">Imply</span> wff1 wff2) <span class="ot">=</span> (<span class="fu">not</span> (eval env wff1)) <span class="op">||</span> (eval env wff2)</span></code></pre></div>
<p>Here <code>eval</code> is defined recursively. For example, to
determine the truth value of <code>(And wff1 wff2)</code> it gets the
truth value of <code>wff1</code> and the truth value of
<code>wff2</code> and applies the <code>&amp;&amp;</code> operation to
those Boolean values.</p>
<p>While we’re at it, we can define a function that takes a WFF as input
and returns its <strong>main connective</strong>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mainConnective ::</span> <span class="dt">WFF</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>mainConnective (<span class="dt">Var</span> _) <span class="ot">=</span> <span class="st">&quot;Variable (no connective)&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mainConnective (<span class="dt">Not</span> _) <span class="ot">=</span> <span class="st">&quot;Not&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>mainConnective (<span class="dt">And</span> _ _) <span class="ot">=</span> <span class="st">&quot;And&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>mainConnective (<span class="dt">Or</span> _ _) <span class="ot">=</span> <span class="st">&quot;Or&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>mainConnective (<span class="dt">Imply</span> _ _) <span class="ot">=</span> <span class="st">&quot;Imply&quot;</span></span></code></pre></div>
<p>The way that WFFs are defined in Haskell makes it easy to read off
the main connective, since it’s simply that last constructor that is
applied in the definition of the relevant WFF. For us human beings, we
read strings of symbols, and we somehow – with practice – develop the
ability to transform this string into a data structure in our minds. (We
are “parsing” the string.) From this data structure in our minds, we
then “see” what the main connective is.</p>
<p>One can define an algorithm that takes as input a string, and returns
the main connective (if that string represents a wff). However, this
kind of algorithm is usually pretty ugly, and it’s certainly not
something that one recommends students to explicitly follow to find the
main connective of a wff.</p>
<h1 id="what-do-truth-tables-mean">What do truth tables mean?</h1>
<h2 id="for-a-single-sentence">For a single sentence</h2>
<p>There are only three ways that the truth table of a single sentence
can turn out. The column under the main connective can have:</p>
<ol type="1">
<li><p>All T, in which case we say that the sentence is a
<strong>tautology</strong>.</p></li>
<li><p>All F, in which case we say that the sentence is an
<strong>inconsistency</strong>.</p></li>
<li><p>Some T and some F, in which case we say that the sentence is a
<strong>contingency</strong>.</p></li>
</ol>
<p>Suppose that you are asked to determine if a sentence is a tautology,
inconsistency, or contingency. This kind of problem can always be
answered by writing out a full truth table (and reading off the data
under the main connective). However, sometimes you can solve the problem
more quickly than that — and in a more satisfying way. For example,
suppose that <span class="math inline"><em>A</em></span> is some
extremely complicated sentence, and that <span
class="math inline"><em>B</em></span> is false on at least one line.
Then <span class="math inline"><em>A</em> ∧ <em>B</em></span> cannot be
a tautology, no matter what truth values <span
class="math inline"><em>A</em></span> can take on. Let’s look at a
couple of examples.</p>
<p><strong>Example.</strong> Classify the sentence <span
class="math inline"><em>P</em> ↔︎ (<em>Q</em>∧¬<em>R</em>)</span> as
tautology, contingency, or inconsistency.</p>
<pre><code>It&#39;s easy to see that this sentence can be true: when P and Q are true
and R is false, then the sentence as a whole is true. Similarly, since
we can just change the truth value of P to false, this sentence can
also be false. Therefore, this sentence is a contingency.</code></pre>
<p>There are more sophisticated, and systematic, ways of doing what I
just did. But for now, I’ll just state a few rules of thumb:</p>
<ol type="1">
<li><p>It’s easy to check that a conjunction is false, because you only
need to find a case where one of its conjuncts is false.</p></li>
<li><p>For the same reason, it’s easy to check that a disjunction is
false.</p></li>
<li><p>The only way that a conditional can be false is when its
antecedent is true and its consequent is false.</p></li>
<li><p>The more practice you get, the more quickly you will be able to
identify standard tautologies and inconsistencies. You will also become
more proficient at recognizing logical implications.</p></li>
</ol>
<p><strong>Exercise.</strong> Classify the following sentences as
tautology, inconsistency, or contingency.</p>
<ol type="1">
<li><p><span
class="math inline"><em>P</em> ∨ ¬<em>P</em></span></p></li>
<li><p><span
class="math inline">(<em>P</em>→¬<em>P</em>) → ¬<em>P</em></span></p></li>
<li><p><span
class="math inline">(<em>P</em>→<em>Q</em>) ∨ (<em>Q</em>→<em>P</em>)</span></p></li>
<li><p><span
class="math inline">(<em>P</em>∧(<em>Q</em>∧¬<em>R</em>)) ∨ (¬<em>P</em>∧(¬<em>Q</em>∧<em>R</em>))</span></p></li>
<li><p><span
class="math inline">(<em>P</em>↔︎<em>Q</em>) ↔︎ <em>R</em></span></p></li>
<li><p><span
class="math inline">((<em>P</em>→<em>Q</em>)→<em>P</em>) → <em>P</em></span></p></li>
</ol>
<p><strong>Exercise.</strong> Show that if <span
class="math inline"><em>B</em></span> is a tautology, then <span
class="math inline"><em>A</em> ∧ <em>B</em></span> is logically
equivalent to <span class="math inline"><em>A</em></span>.</p>
<p><strong>Exercise.</strong> Show that if <span
class="math inline"><em>B</em></span> is an inconsistency, then <span
class="math inline"><em>A</em> ∨ <em>B</em></span> is logically
equivalent to <span class="math inline"><em>A</em></span>.</p>
<h2 id="for-n1-sentences">For <span
class="math inline"><em>n</em> &gt; 1</span> sentences</h2>
<p>If we now put <span class="math inline"><em>n</em> &gt; 1</span>
sentences side by side in a truth table, then we can answer questions
about the <em>semantic relationships</em> between those sentences. For
example, if sentences <span
class="math inline"><em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em></sub></span>
can be true simultaneously, then we say that they are
<strong>consistent</strong>. Similarly, if <span
class="math inline"><em>A</em><sub>1</sub>, …, <em>A</em><sub><em>n</em></sub></span>
cannot be true simultaneously, then we say that they are
<strong>inconsistent</strong>.</p>
<p>For two sentences, <span class="math inline"><em>A</em></span> and
<span class="math inline"><em>B</em></span>, we say that <span
class="math inline"><em>A</em></span> <strong>implies</strong> <span
class="math inline"><em>B</em></span> just in case <span
class="math inline"><em>B</em></span> is true whenever <span
class="math inline"><em>A</em></span> is. We say that <span
class="math inline"><em>A</em></span> and <span
class="math inline"><em>B</em></span> are <strong>equivalent</strong>
just in case <span class="math inline"><em>A</em></span> implies <span
class="math inline"><em>B</em></span> and vice versa. Thus, <span
class="math inline"><em>A</em></span> and <span
class="math inline"><em>B</em></span> are equivalent just in case they
have the same truth value in all rows of their joint truth table.</p>
<p><strong>Exercise.</strong> What is the semantic relationship between
<span class="math inline"><em>P</em> → <em>Q</em></span> and <span
class="math inline">¬<em>P</em> ∨ <em>Q</em></span>?</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">P</th>
<th style="text-align: center;">Q</th>
<th style="text-align: center;">P → Q</th>
<th style="text-align: center;">¬P ∨ Q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
</tr>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>These two sentences always have the same truth value, thus they are
logicall equivalent.</p>
<p><strong>Exercise.</strong> Show that <span
class="math inline">¬(<em>P</em>→<em>Q</em>)</span> logically implies
<span class="math inline"><em>P</em> ∧ ¬<em>Q</em></span>.</p>
<pre><code>Suppose that -(p&gt;q) is true. In that case p&gt;q is false, which means
that p is true and q is false. But in the case, p&amp;-q is true.</code></pre>
<p><strong>Exercise:</strong> What is the semantic relationship between
<span class="math inline">(<em>P</em>∧<em>Q</em>)</span> and <span
class="math inline">¬(<em>P</em>→<em>Q</em>)</span>?</p>
<p><strong>Exercise:</strong> If <span
class="math inline"><em>ϕ</em> ∧ <em>ψ</em></span> is a contingency,
then can you say anything about <span
class="math inline"><em>ϕ</em></span> and <span
class="math inline"><em>ψ</em></span>?</p>
<p><strong>Exercise:</strong> If <span
class="math inline"><em>ϕ</em></span> is a tautology, then what are the
possibilities for <span
class="math inline"><em>ϕ</em> ∧ <em>ψ</em></span>? What are the
possibilities for <span
class="math inline"><em>ϕ</em> ∨ <em>ψ</em></span>?</p>
<h2 id="for-arguments">For arguments</h2>
<p>An argument consists of <span
class="math inline"><em>n</em> ≥ 1</span> sentences: a conclusion, and
<span class="math inline"><em>n</em> − 1</span> premises. (Yes, we can
also have arguments with zero premises.) We can set these sentences side
by side and build a joint truth table, and here is how to interpret such
a truth table:</p>
<ol type="1">
<li><p>If, in every row in which all the premises are true, the
conclusion is also true, then the argument is said to be
<strong>valid</strong>.</p></li>
<li><p>If there is some row in which all the premises are true but the
conclusion is false, then the argument is said to be
<strong>invalid</strong>.</p></li>
</ol>
<p>If we let <span class="math inline"><em>ψ</em></span> denote the
conclusion, and <span
class="math inline"><em>ϕ</em><sub>1</sub>, …, <em>ϕ</em><sub><em>n</em> − 1</sub></span>
denote the premises, then the argument <span
class="math inline"><em>ϕ</em><sub>1</sub>, …, <em>ϕ</em><sub><em>n</em></sub>; <em>ψ</em></span>
is valid just in case <span
class="math inline"><em>ϕ</em><sub>1</sub>, …, <em>ϕ</em><sub><em>n</em> − 1</sub>, ¬<em>ψ</em></span>
forms an inconsitent <span class="math inline"><em>n</em></span>-tuple
of sentences. In other words: the argument is invalid just in case <span
class="math inline"><em>ϕ</em><sub>1</sub>, …, <em>ϕ</em><sub><em>n</em> − 1</sub>, ¬<em>ψ</em></span>
is consistent, i.e. there is a row in the truth table in which they are
all true. Such a row of a truth table is called a
<strong>counterexample</strong> to the argument’s validity.</p>
<p><strong>Exercises.</strong> Determine whether the following arguments
are valid or not. Explain your answer by showing the existence of a row
of a truth table, or by pointing to a full truth table, or something of
the sort. Your answer should be articulated in English prose so that it
can convince anyone else who is familiar with truth tables.</p>
<ol type="1">
<li><p><span
class="math inline"><em>P</em> → (<em>Q</em>→<em>R</em>) ⊢ (<em>P</em>∧<em>Q</em>) → <em>R</em></span></p></li>
<li><p><span
class="math inline"><em>P</em> → <em>R</em>  ⊢ (<em>P</em>∨<em>Q</em>) → <em>R</em></span></p></li>
</ol>
<h1 id="philosophical-issues">Philosophical issues</h1>
<p>Our target in this course is the notion of logical validity. But we
now have <em>two</em> different explications of this concept: one in
terms of provability, and one in terms of semantics (truth tables). Is
one of these two notions more basic than the other? What does it
<em>really</em> mean to say that an argument is valid?</p>
<h1 id="extra-credit-fun">Extra credit (fun)</h1>
<ol type="1">
<li><p>How many possible truth tables are there for sentences that
contain only the atomic sentence <span
class="math inline"><em>P</em></span>?</p></li>
<li><p>For sentences with just the atomic sentence <span
class="math inline"><em>P</em></span>, show that every truth table is
represented by a sentence whose only connectives are <span
class="math inline">∧</span> and <span
class="math inline">¬</span>.</p></li>
</ol>
</body>
</html>
